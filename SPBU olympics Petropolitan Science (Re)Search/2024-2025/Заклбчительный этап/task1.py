# Описание решения:
# 1) Считываем число вершин и массив предков, преобразуя его в 1-индексированный вид
# 2) Строим список детей для каждой вершины и для вершин с детьми выбираем первого ребенка как продолжение цепочки
# 3) Вершины, не являющиеся продолжением (не выбранные как ребенок), служат началом новых путей, по которым идем вниз до конца цепи.
# 4) Таким образом, получаем минимальное разбиение дерева на пути, покрывающее все вершины

n=int(input().strip())
p_values=list(map(int,input().split()))
p=[0]+p_values # добавляем фиктивный элемент на позицию 0


children=[[] for i in range(n+1)]
root=-1
for i in range(1,n+1):
    if p[i]==i:
        root=i # определяем корень
    else:
        children[p[i]].append(i)

# массив nxt для определения продолжения цепочки для кадждой вершины         
nxt=[0]*(n+1)
# флаг is_chosen - если вершина была выбрана как продолжение чей-либо цепочки, то она будет началом нового пути
is_chosen=[False]*(n+1)

# для каждой вершиной с детьми выбираем одного ребенка для продолжения пути (например, первого в списке)
for u in range(1,n+1):
    if children[u]:
        v=children[u][0] # выбираем первого ребенка
        nxt[u]=v
        is_chosen[v]=True # помечаем, что вершина v была выбрана как продолжение

# формирование путей: каждая вершина не являющаяся продолжением, начинает новый путь 
        
paths=[]
for i in range(1,n+1):
    if not is_chosen[i]:
        path=[]
        cur=i
        # строим путь, пока есть выбранный ребенок
        while cur:
            path.append(cur)
            if nxt[cur]:
                cur=nxt[cur]
            else:
                break
        paths.append(path)

# выводим рзультат            
print(len(paths))
for path in paths:
    print(len(path))
    print(" ".join(map(str,path)))
                	 	  	   	    	   		   	  		   	 	
